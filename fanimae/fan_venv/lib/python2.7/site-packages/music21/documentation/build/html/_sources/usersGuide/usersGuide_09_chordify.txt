.. _usersGuide_09_chordify:

.. WARNING: DO NOT EDIT THIS FILE:
   AUTOMATICALLY GENERATED.
   PLEASE EDIT THE .py FILE DIRECTLY.



User's Guide, Chapter 9: Chordify
=================================

**Chordify** is a madeup word that we created in ``music21`` for the
process of making chords out of non-chords. Chordify powerful tool for
reducing a complex score with multiple parts to a succession of chords
in one part that represent everything that is happening in the score.
Take this short chorale by Bach:

.. code:: python

    from music21 import *
    
    b = corpus.parse('bwv66.6')
    b.show()




.. image:: usersGuide_09_chordify_3_0.png



Let's take it and chordify it using the
:meth:`~music21.stream.Stream.chordify` method.

.. code:: python

    bChords = b.chordify()
    bChords.show()




.. image:: usersGuide_09_chordify_5_0.png



TA-DA! Every note in the score is now represented in a single chord and
every moment where some element moves is also represented. Sometimes
this process of chordifying is called "salami slicing," that is, cutting
the score so thinly that every moment where something happens is fully
represented.

Now we can see if there are any (fully-notated) dominant seventh chords
in the piece. The new chordified part still has measures, so we'll
flatten the chordified part first to get to the chords. It might also
have time signatures, etc., so we will filter them out so we only have
chords.

.. code:: python

    for thisChord in bChords.recurse().getElementsByClass('Chord'):
        if thisChord.isDominantSeventh():
            print(thisChord.measureNumber, thisChord.beatStr, thisChord)


.. parsed-literal::
   :class: ipython-result

    2 2 1/2 <music21.chord.Chord B4 G#4 D4 E3>
    3 2 1/2 <music21.chord.Chord G#4 E#4 B3 C#3>
    4 3 1/2 <music21.chord.Chord F#4 D#4 A3 B2>
    8 2 <music21.chord.Chord F#4 E4 C#4 A#2>


Sure enough we can check the score above and see that there are four of
them: three of them on the offbeat (m.2 beat 2.5, m. 3 beat 2.5, and m.
4 beat 3.5) which are made from passing motion, and one of them in m. 8
beat 2 also in a metrically weak position.

We can see the chordified version by callling ".show()" on ``bChords``
itself, but it's probably better to see it in the context of the whole
score. Let's put it in the score at the beginning (all ``Part`` objects
should go at the beginning) and then show just measures 0 (pickup) to 4:

.. code:: python

    b.insert(0, bChords)
    b.measures(0, 4).show()




.. image:: usersGuide_09_chordify_10_0.png



That's a bit messy to read, so let's put all these chords in
``closedPosition`` (see
:ref:`User's Guide, Chapter 7: Chords <usersGuide_07_chords>` for more
information).

.. code:: python

    for c in bChords.recurse().getElementsByClass('Chord'):
        c.closedPosition(forceOctave=4, inPlace=True)
    
    b.measures(0,2).show()




.. image:: usersGuide_09_chordify_12_0.png



Note that when we move a chord to closed position, unfortunately it
loses its ``tie`` information, since the pitch that starts a tie can't
tell whether or not the next pitch will end up in a different octave
(for instance, the Cs in the first two notes of the second full
measure). Maybe it's something we can do someday...

We can use the function ``roman.romanNumeralFromChord`` to label each of
the chordified Chords:

.. code:: python

    for c in bChords.recurse().getElementsByClass('Chord'):
        rn = roman.romanNumeralFromChord(c, key.Key('A'))
        c.addLyric(str(rn.figure))
        
    b.measures(0, 2).show()




.. image:: usersGuide_09_chordify_14_0.png



We can also see everything directly if we look at the ``.show('text')``
output:

.. code:: python

    bChords.measures(0,2).show('text')


.. parsed-literal::
   :class: ipython-result

    {0.0} <music21.stream.Measure 0 offset=0.0>
        {0.0} <music21.clef.TrebleClef>
        {0.0} <music21.key.KeySignature of 3 sharps, mode minor>
        {0.0} <music21.meter.TimeSignature 4/4>
        {0.0} <music21.chord.Chord A4 C#5 E5>
        {0.5} <music21.chord.Chord G#4 B4 E5>
    {1.0} <music21.stream.Measure 1 offset=1.0>
        {0.0} <music21.chord.Chord F#4 A4 C#5>
        {1.0} <music21.chord.Chord G#4 B4 E5>
        {2.0} <music21.chord.Chord A4 C#5 E5>
        {3.0} <music21.chord.Chord G#4 B4 E5>
    {5.0} <music21.stream.Measure 2 offset=5.0>
        {0.0} <music21.chord.Chord A4 C#5 E5>
        {0.5} <music21.chord.Chord C#4 E4 A4>
        {1.0} <music21.chord.Chord E4 G#4 B4>
        {1.5} <music21.chord.Chord E4 G#4 B4 D5>
        {2.0} <music21.chord.Chord A4 C#5 E5>
        {3.0} <music21.chord.Chord E#4 G#4 C#5>


We can also just extract the lyrics, where we stored the RomanNumeral
information:

.. code:: python

    for c in bChords.measures(0,2).flat:
        if 'Chord' not in c.classes:
            continue
        print(c.lyric, end=' ')


.. parsed-literal::
   :class: ipython-result

    I V6 vi V6 I V6 I I6 V V7 I III6 

More complex scores can also be chordified. If there are lots of
tuplets, you might get odd results. Such as with Opus 19, no. 6, by
Arnold Schoenberg.

.. code:: python

    schoenberg = corpus.parse('schoenberg/opus19', 6)
    schoenberg.show()




.. image:: usersGuide_09_chordify_20_0.png



.. code:: python

    schoenberg.chordify().show()




.. image:: usersGuide_09_chordify_21_0.png



There are more specialized commands for ``.chordify``, so if you want to
learn more, look at the :meth:`~music21.stream.Stream.chordify`
documentation. We will get to the option, ``addPartNameAsGroup`` later,
which will let you know exactly where each pitch in the chordified Chord
comes from. But for now, let's jump to our first example,
:ref:`Chapter 10: Example 1 <usersGuide_10_examples1>`